package utils

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"
)

// GetResolvedTag determines the final image tag based on user input or auto-generation.
// If userProvidedTag is not empty, it's used directly.
// Otherwise, a tag in YYYY.MM.DD.commit_hash format is generated.
func GetResolvedTag(userProvidedTag string) (string, error) {
	resolvedTag := userProvidedTag
	if resolvedTag == "" {
		// If no tag is provided via flag, generate one
		commitHash, err := getGitCommitHash()
		if err != nil {
			return "", fmt.Errorf("failed to get git commit hash for auto-tagging: %v", err)
		}
		dateTag := getFormattedDate()
		resolvedTag = fmt.Sprintf("%s.%s", dateTag, commitHash[:7]) // Use short commit hash
		fmt.Printf("Info: No tag provided via --tag flag. Auto-generated tag: %s\n", resolvedTag)
	} else {
		fmt.Printf("Info: Using tag provided via --tag flag: %s\n", resolvedTag)
	}
	return resolvedTag, nil
}

// ExecuteDockerRetag performs the 'docker tag' operation.
// It takes the final resolved tag, service name, and image registry to construct
// the source (local) and target (remote) image names.
func ExecuteDockerRetag(resolvedTag, serviceName, imageRegistry string) error {
	localSourceImage := fmt.Sprintf("local-registry/%s", serviceName)
	targetImage := fmt.Sprintf("%s/%s:%s", imageRegistry, serviceName, resolvedTag)

	fmt.Printf("Info: Attempting to retag local image '%s' to '%s'...\n", localSourceImage, targetImage)
	cmd := exec.Command("docker", "tag", localSourceImage, targetImage)

	// Pipe docker command's stdout/stderr to our program's output for visibility
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to retag docker image '%s' to '%s'. Ensure 'docker' is installed and image '%s' exists locally: %v", localSourceImage, targetImage, localSourceImage, err)
	}
	fmt.Printf("Info: Image successfully retagged to '%s'.\n", targetImage)
	return nil
}

// HandleImageTaggingAndRetagIfAutoGenerated orchestrates the docker tagging process.
// It checks if the tag was auto-generated (i.e., userProvidedTag is empty) and, if so,
// extracts necessary configuration from 'values' and performs the docker retag operation.
func HandleImageTaggingAndRetagIfAutoGenerated(userProvidedTag, resolvedTag string, values map[string]interface{}) error {
	// This logic runs only if the user did NOT provide a tag via --tag flag.
	if userProvidedTag == "" {
		// Extract necessary top-level values for docker tagging
		topLevelServiceName, ok := values["SERVICE_NAME"].(string)
		if !ok || topLevelServiceName == "" {
			return fmt.Errorf("top-level 'SERVICE_NAME' not found or is empty in values.yaml, required for auto-tagging local images")
		}
		topLevelImageRegistry, ok := values["IMAGE_REGISTRY"].(string)
		if !ok || topLevelImageRegistry == "" {
			return fmt.Errorf("top-level 'IMAGE_REGISTRY' not found or is empty in values.yaml, required for auto-tagging local images")
		}

		// Call the utility function to perform the docker retag
		if err := ExecuteDockerRetag(resolvedTag, topLevelServiceName, topLevelImageRegistry); err != nil {
			return err // Error propagated from the tagging utility
		}
	}
	return nil
}

// getGitCommitHash executes 'git rev-parse HEAD' to get the current commit hash.
func getGitCommitHash() (string, error) {
	cmd := exec.Command("git", "rev-parse", "HEAD")
	output, err := cmd.Output()
	if err != nil {
		exitErr, ok := err.(*exec.ExitError)
		if ok {
			return "", fmt.Errorf("git command failed with: %s (stderr: %s)", exitErr.Error(), string(exitErr.Stderr))
		}
		return "", fmt.Errorf("failed to execute git command: %v", err)
	}
	return strings.TrimSpace(string(output)), nil
}

// getFormattedDate returns the current date in YYYY.MM.DD format.
func getFormattedDate() string {
	return time.Now().Format("2006.01.02")
}
